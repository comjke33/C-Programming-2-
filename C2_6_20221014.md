**포인터 변수**

- 주소는 모두 상수
- pointer 변수는 메모리 번지(주소)를 저장하는데 쓰이는 변수
- 주소를 저장, 처리할 수 있는 것이 포인터 변수
- 포인터 변수를 바꾸면 가리키는 메모리 위치가 변경됨
- 저장되는 주소 Byte 단위의 주소
    - 1byte 2byte 4byte 구분해주는 것이 포인터 변수의 형 type 즉, char, short, int 등
    - 포인터 char형 변수가 100이면 100~100
    - 포인터 int형 변수가 100이면 100~103
- 포인터 변수가 필요한 이유
    - 데이터들의 집합을 필요에 따라 가리키고 변경하는 처리를 할 필요성
- 포인터 변수
    - 포인터 변수 선언은 일반적인 변수 선언 앞에 *를 붙인다.
    - *는 1개 이상 자유롭게 붙일 수 있다.
    - int *p의 다음은 1004
    - char *p의 다음은 1001
    - 각 데이터별 크기가 다르기 때문
    - struct도 포인터로 가리킬 수 있음
    - +,-는 다음, 이전의 개념

---

**포인터 변수의 초기화**

```objectivec
int *p, i;
p=0;
p= NULL;
p= &i;
p= (int *)1776;
```

1. p에 0번지를 넣는다
2. NULL = 0 같은 의미
3. p에 i의 주소 번지값을 넣음
4. 정수 상수 1776을 정수 포인터로 변환한 값을 넣음
5. 임베디드는 특정 메모리를 이용하는 경우가 많음
6. PC는 특정 메모리를 이용하지 X, 운영체제가 지정해주는 메모리를 할당
- &연산자: 변수의 주소(번지)를 돌려주는 연산자
- &p : 변수 p의 주소
- scanf(”%d”, &p);
- type cast: 형변환하는 연산자
    - ex) (float)i

---

```objectivec
#include <stdio.h>
	int main(){
	int a=6;
	float b=39;
	float c;
	c= b/a;
	printf("%d",c);
}
```

- c는 무엇이 나올까? 아마 6.0이 나올 것이다.
- b/a = 39/6 =6

---

**배열과 포인터의 관계**

```objectivec
int a[100];
a[0] = 1000번지;
int *ipr;
ipr = &a;
```

- a의 값을 ipr에 넣는다
- ipr은 1000번지라는 주소를 가지게 된다.
- ipr이 가리키는 주소는 a[0]의 주소이다.
- 포인터 ipr의 배열 a[100]
- ipr은 1000의 값을 가지게 됨.
- ipr은 a[0]를 가리키고 있는 것임
- 실제로 컴퓨터에서는 a가 없어짐. 번지도 없어짐. 값만 남음
- ipr로 할 수 있는 일
    - *ipr은 a[0]이다
    - a[0]은 *(ipr+0)을 의미
    - C언어에서는 []가 연산자
    - ipr+1
    - a[0]의 다음 원소 덩어리 a[1]를 의미
    - ipr은 int형 pointer로 선언되었기 때문에 ipr+1은 1004번지를 나타냄.
    - 따라서 *(ipr+1) = a[1]
    - a[3] = *(a+3)
    - 3[a] = *(3+a)
    - a[(-2)] = *(a-2)
    - (-2)[a]= *((-2)+a)

---

```objectivec
unsigned char *p1, *p2,
							a[100] ={0}, b[2][3][5], c=7, d=128;
int i=1029, *ip;
p1 = &i;
ip = &c;
```

char형 포인터로 int형 변수를 가르킴. 4byte 중 1byte만 가르킬 수 있음

i는 1029 = 1024+5이므로

100 0000 0101인데 1byte인 0100만 가르킴 그럼 p1은 4인 것

int형 포인터 ip는 char형 7을 가르킴

7= 0111 0000 0000 0000 이렇게 가르킴. 마지막 12bit는 0일지 아닐지 모름
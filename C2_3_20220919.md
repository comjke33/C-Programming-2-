```objectivec
int main(){
	char a,b,c,d;
	int i,j,k;
	char e,f,g;
	int l;
	char h;
	int m;
	char x[7];
	m=0;
}
```

1. 내가 만든 순서대로 항상 저장되는 것은 아니다.
    1. 높은 주소 → 낮은 주소 (스택구조)
2. 데이터는 떨어져있다. → 불연속적
3. 배열은 전체 순서와 관계없이 낮은 주소 → 높은 주소 → 연속적

---

배열의 종류

- 모든 데이터형을 배열로 만들 수 있다.
- 포인터도 배열의 데이터가 될 수 잇다.
    - 배열도 포인터가 될 수 있다.
- 일정한 형태의 데이터가 같은 크기로 계속 반복되어 연속으로 저장된다.
- 문자열은 연속으로 출력되는 등의 처리를 할 수 있다. string copy

---

배열의 초기화

```objectivec
float f[3] ={0.0,1.9,-9.7};
int a[100] ={0,};
int b[100]={1};
int c[100]={1,};
```

1. {0,}; → 0으로 초기화
2. {1}와 {1,}의 공통점: 둘다 첫 원소만 1이고 나머지 원소는 0이다
3. 만약 초기화하는 상수의 갯수가 총 원소의 갯수보다 작으면 나머지는 모두 0으로 초기화.
4. C는 엄격하게 체크하지 않음. 범위에 벗어나게 초기화했는지의 여부는 따지지 않느다.

```objectivec
int aa[]={1,2};
int aa[2]={1,2};
```

1. 둘은 같은 코딩.

---

문자열

- “” 쌍따옴표를 쓰면 0이 자동으로 생기고 문자열에는 0이 들어갈 자리가 꼭 있어야함.
- Null string : 비어있는 문자열 → 문자열에 NULL밖에 없음
- 문자열은 반드시 NULL로 끝나야한다.
- 문자열은 printf등 함수에서 연속으로 출력될 수 잇으므로 끝을 지정하지 않으면 끝낼 수가 없다.
- “” 연속이라서 주소
- ‘’ 아스키코드값
- ex) i am a \0 boy을 쓰면 %s가 boy는 읽지 못함.
- 문자열은 변수 종류에 관계 없음.
- 낮은 번지 → 높은 번지로 순서대로 저장됨
- \0은 특수문자임

---

문자열과 배열 1

- 문자열을 저장할 때는 \0도 포함해야함
- 인덱스는 0부터 시작함

---

문자열과 배열 2

- 연속된 메모리에 저장된다는 보장이 없다
    - 운영체제의 상황에 따라 위치가 달라진다.
- 배열은 무조건 연속으로 저장
- 변수, 상수
    - 변수: 변할 수 있는 수 → 실행 시 이름이 사라짐. 실제 주소와 위치로 바뀜
    - 상수: 변하지 않는 수

---

1차원 char 배열에서의 주소와 그 표현

```objectivec
char a[12] = "I am a boy";
```

1. a[0]는 ‘I’인 변수
2. &a[0]은 a[0] 문자의 주소인 상수
3. &a[0]는 a와 같음 → 배열의 이름은 첫번째 덩어리 주소 %p로 출력가능

---

char a[12] =”I am a boy” → 컴퓨터가 하는 일

- 문자열일때만 쌍따옴표 안 내용을 모아서 허용된 메모리에 넣음
- Read only memory(ROM)
    - 실제로 하나 (텍스트 영역-상수값을 저장하는 영역)
    - 변수 공간에 하나 (변수 공간에 다시 복사)
- 컴파일러는
    - 변수 이름을 없앰
    - 상대주소로 바꿈
    - 자료형에 따라 맞는 주소을 계산함

---

상수 vs 변수

- 상수: 주소값 &a[0] → 주소를 변경할 수 없음
- 변수: 문자열 a[0]

---

1차원 int 배열의 주소와 표현

- &i[0] = i
    - 배열의 이름은 첫번째 덩어리 주소
- &c[2] - &c[0] = &i[2] - &i[0] =2
- 주소값에서 +,-는 다음, 이전의 의미
- 주소 - 연산은 char와 int가 몇 개 들어가는 공간인지 구하는 것
- 인덱스 차이를 구하려면…
    - &a[2] - &a[0]
- 실제 메모리 차이를 구하려면…
    - (int)&a[2] -(int)&a[0] → 캐스팅 연산 하면 됨.
    - 주의! 같은 종류를 빼야함. 그렇지 않으면 오류가 뜸.
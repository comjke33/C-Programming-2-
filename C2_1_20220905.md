***첫 번째***

```objectivec
#include <stdio.h>
int main(){
	int a,b,c;
	printf("Input Data:");
	scanf("%d %d", &a, &b);
	c= a+b;
	printf("%d",c);
}
```

1. #include → 가독성을 위해 불러오는 내용
2. <stdio.h> → 헤더파일 
    - <> : 미리 만들어놓은 라이브러리
    - “”: 내가 만들어놓은 라이브러리

1. int main → main 앞에 붙여주면 좋지만 안 붙여줘도 작동은 함
2. printf, scanf : 표준함수의 대표적인 예시
3. &: 주소를 불러옴.
4. c= a+b 에서 c는 a+b의 값을 대입할 L value이다.

---

**컴파일을 할 때…**

- C언어(인간이 코딩한 내용) → 헤더파일(대충 번역해서 빠르게 만들어낼 때 이름과 모양만 구현) →라이브러리(진짜 기능을 구현)
- 헤더파일: 이름과 기능이 간단히 적혀있음
- 라이브러리: 실제 기능이 정의됨

---

***두 번째***

```objectivec
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

main(){
	unsigned char a[4] ={0,},b;
	printf("Input Data:");
	scanf("%d", (int*)&a[0]);
	b= a[0] + a[3];
	printf("%d\n", b);
}
```

1. define 오류 방지 코드는 PC기반에서는 적어주어야 하고, 리눅스에서는 안 적어도 된다.
2. (int*)는 이 순간만 integer로 바꾸는 것 → cast 연산

---

- PC에서 scanf가 오류나는 이유: 매우 복잡해서 보안에 취약하기 때문
- 디버깅 감시자 → 코딩 후 F11를 누르고 변수 이름을 적으면 볼 수 있음
- a → 그냥 적기만 하면 10진수로 보여줌
- a, x  → 콤마 x하면 16진수로 보여줌
- 모든 것은 bit로 저장
- 전압을 측정해서 일정한 값 이상이면 1, 아니면 0으로 정의
- 폰노이만 방식 → input, output을 하나로
- Non폰노이만 방식 → input과 output을 분리 (동시 진행 가능)
- 양자 컴퓨터 → 수많은 정보를 처리가능
    - 큐비트 (컴퓨터 혁명 中 1)
- 컴퓨터의 코드 처리 방식
    - 프로그래밍 → assembly (CPU에서 진행) → 16진수
- 비트 연산
    - &, &&의 차이
        - &: 주소값을 불러들이는 기호
        - &&: 참과 거짓을 따지는 AND의 기호
    - 3&4 → 000
    - 3&&4 → 1
    - 3&5 → 1
    - —> 이런 자잘한 실수가 프로그램 실험의 치명적인 허점을 만든다.